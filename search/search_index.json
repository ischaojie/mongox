{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MongoX MongoX is an async python ODM (Object Document Mapper) for MongoDB which is built on top Motor and Pydantic . The main features include: Fully type annotated Async support Python 3.7+ (since it's built on top of Motor) Elegant editor support (since it's built on top of Pydantic) Autocompletion everywhere, from object creation to query results Custom query builder which is more intuitive and pythonic 100% test coverage MongoX models are at the same time Pydantic models and have the same functionalitties, so you can use them with your existing Pydantic models. Documentation : https://aminalaee.github.io/mongox Installation $ pip install mongox Quickstart You can define mongox models the same way you define Pydantic models. The difference is they should inherit from mongox.Model now: import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" , get_event_loop = asyncio . get_running_loop ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model ): name : str year : int class Meta : collection = db . get_collection ( \"movies\" ) Now you can create some instances and insert them into the database: movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. So you will have type hints and validations everywhere: Now you can fetch some data from the database. You can use the same pattern as PyMongo/Motor: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. This will have great IDE support, autocompletion and validation. Or you can use Movie fields instead of dictionaries in the query (less room for bugs): movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use a more intuitive query (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Notice how we omitted the dictionary and passed the Movie fields in comparison. Please refer to the documentation here or the full examples here .","title":"Quickstart"},{"location":"#mongox","text":"MongoX is an async python ODM (Object Document Mapper) for MongoDB which is built on top Motor and Pydantic . The main features include: Fully type annotated Async support Python 3.7+ (since it's built on top of Motor) Elegant editor support (since it's built on top of Pydantic) Autocompletion everywhere, from object creation to query results Custom query builder which is more intuitive and pythonic 100% test coverage MongoX models are at the same time Pydantic models and have the same functionalitties, so you can use them with your existing Pydantic models. Documentation : https://aminalaee.github.io/mongox","title":"MongoX"},{"location":"#installation","text":"$ pip install mongox","title":"Installation"},{"location":"#quickstart","text":"You can define mongox models the same way you define Pydantic models. The difference is they should inherit from mongox.Model now: import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" , get_event_loop = asyncio . get_running_loop ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model ): name : str year : int class Meta : collection = db . get_collection ( \"movies\" ) Now you can create some instances and insert them into the database: movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. So you will have type hints and validations everywhere: Now you can fetch some data from the database. You can use the same pattern as PyMongo/Motor: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () The returned result will be a Movie instance, and mypy will understand that this is a Movie instance. This will have great IDE support, autocompletion and validation. Or you can use Movie fields instead of dictionaries in the query (less room for bugs): movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use a more intuitive query (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Notice how we omitted the dictionary and passed the Movie fields in comparison. Please refer to the documentation here or the full examples here .","title":"Quickstart"},{"location":"defining_documents/","text":"As you probably already know, MongoDB databases have collections instead of tables. And each collection has documents instead of rows. You can define your documents by inheriting from mongox.Model . import asyncio import mongox client = mongox . Client ( \"mongodb://localhost:27017\" , get_event_loop = asyncio . get_running_loop ) db = client . get_database ( \"test_db\" ) class Movie ( mongox . Model ): name : str year : int class Meta : collection = db . get_collection ( \"movies\" ) Model attributes are defined the same way as Pydantic. The Movie class is both a mongox Model and also a pydantic BaseModel . Now we have a Movie collection with attributes name and year . Note The Meta class is required since we need to know which collection this belongs to.","title":"Defining documents"},{"location":"queriying_documents/","text":"Inserting documents In order to work with documents we'll first need to insert some. MongoX provides an insert method to the document instances. movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () Of course we can also do it in two steps: movie = Movie ( name = \"Forrest Gump\" , year = 1994 ) movie = await movie . insert () The great thing about MongoX is that since it's fully type annotated, you will have great mypy and IDE support. Since Movie model is also a Pydantic model, you will have autocompletion in your IDE to know which fields are required. And you will also know that the result of insert will be a Movie instance. This will lead to more productivity and fewer runtime errors. Let's say you try to access genre of movie: print ( movie . genre ) Here mypy and your IDE will complain that the Movie class has no attribute genre . Querying documents MongoX supports the same queries Motor/PyMongo support and besides that, also introduces two other options. Let's say you want to query for a single document: You can do it the usual way, by passing a dictionary of key, values to filter: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () You can also query by Movie class fields: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use the new query builder (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Here you will again have graet IDE and MyPy support, as they will know the returned type of get will be a Movie . So you can access movie attributes safely. Query methods Here is the list of supported query methods: first returns the first matching document: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . first () get returns the only matching document or throws exceptions: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () Note This can raise NoMatchFound or MultipleMatchesFound all returns all documents matching the criteria: movies = await Movie . query () . all () This will return all matched documents. It's up to the caller to set the appropriate limits. count returns count of documents matching the criteria: count = await Movie . query ({ Movie . year : 1994 }) . count () sort to sort documents the same way Motor/PyMongo allows: movies = await Movie . query () . sort ([( Movie . name , mongox . Order . DESCENDING )]) . all () You can use Order from mongox to have ASCENDING or DESCENDING order. limit to limit number of documents returned: movies = await Movie . query () . limit ( 5 ) . all () This will ensure that only 5 documents are returned. skip number of documents to skip: movies = await Movie . query () . skip ( 5 ) . all () This will skip the first 5 documents and return the rest. Sometimes skip is used with limit together: movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all () Chaining queries Some of the query methods return results including: all count first get These methods will return final results and should only be the last part of the query: movie = await Movie . query () . all () But some of the query methods return queryset again, so you can chain them together: query sort skip limit movies = await Movie . query ({ Movie . name : \"Example\" }) . skip ( 10 ) . limit ( 20 ) . all () movies = await Movie . query ({ Movie . name : \"Example\" }) . query ({ Movie . year : 2005 }) . all () Updating documents MongoX provides the same updateOne and updateMany functions in MongoDB, but with a different API. You can update a document by calling save on it: movie = await Movie . query () . get () movie . name = \"Another Movie\" movie = await movie . save () Here the output of save will also be a Movie instance. This is the equivalent of a MongoDB updateOne . You can also do bulk updates like this: movies = await Movie . query ({ Movie . year : 1970 }) . update ({ Movie . year : 1980 }) Here we do an update to change the year of all 1970 movies to 1980. The returned result is a list of update Movie instances. This is the equivalent of updateMany in MongoDB. Note Note how bulk update is called on Movie class, but single update is called on Movie instance. Deleting documents The same as update, MongoX provides MongoDB deleteOne and deleteMany functions but with a different API. In order to delete a single document you should get a document first, then call delete on it: movie = await Movie . query () . get () await movie . delete () This will remove the movie instance and it is the equivalent of a deleteOne . To delete multiple documents at the same time: number_of_deleted = await Movie . query ({ Movie . year : 1980 }) . delete () This will remove all documents having year equal to 1980, and the returned result is the number of documents deleted.","title":"Working with documents"},{"location":"queriying_documents/#inserting-documents","text":"In order to work with documents we'll first need to insert some. MongoX provides an insert method to the document instances. movie = await Movie ( name = \"Forrest Gump\" , year = 1994 ) . insert () Of course we can also do it in two steps: movie = Movie ( name = \"Forrest Gump\" , year = 1994 ) movie = await movie . insert () The great thing about MongoX is that since it's fully type annotated, you will have great mypy and IDE support. Since Movie model is also a Pydantic model, you will have autocompletion in your IDE to know which fields are required. And you will also know that the result of insert will be a Movie instance. This will lead to more productivity and fewer runtime errors. Let's say you try to access genre of movie: print ( movie . genre ) Here mypy and your IDE will complain that the Movie class has no attribute genre .","title":"Inserting documents"},{"location":"queriying_documents/#querying-documents","text":"MongoX supports the same queries Motor/PyMongo support and besides that, also introduces two other options. Let's say you want to query for a single document: You can do it the usual way, by passing a dictionary of key, values to filter: movie = await Movie . query ({ \"name\" : \"Forrest Gump\" }) . get () You can also query by Movie class fields: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () And finally you can use the new query builder (limited yet): movie = await Movie . query ( Movie . name == \"Forrest Gump\" ) . get () Here you will again have graet IDE and MyPy support, as they will know the returned type of get will be a Movie . So you can access movie attributes safely.","title":"Querying documents"},{"location":"queriying_documents/#query-methods","text":"Here is the list of supported query methods: first returns the first matching document: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . first () get returns the only matching document or throws exceptions: movie = await Movie . query ({ Movie . name : \"Forrest Gump\" }) . get () Note This can raise NoMatchFound or MultipleMatchesFound all returns all documents matching the criteria: movies = await Movie . query () . all () This will return all matched documents. It's up to the caller to set the appropriate limits. count returns count of documents matching the criteria: count = await Movie . query ({ Movie . year : 1994 }) . count () sort to sort documents the same way Motor/PyMongo allows: movies = await Movie . query () . sort ([( Movie . name , mongox . Order . DESCENDING )]) . all () You can use Order from mongox to have ASCENDING or DESCENDING order. limit to limit number of documents returned: movies = await Movie . query () . limit ( 5 ) . all () This will ensure that only 5 documents are returned. skip number of documents to skip: movies = await Movie . query () . skip ( 5 ) . all () This will skip the first 5 documents and return the rest. Sometimes skip is used with limit together: movies = await Movie . query () . skip ( 5 ) . limit ( 5 ) . all ()","title":"Query methods"},{"location":"queriying_documents/#chaining-queries","text":"Some of the query methods return results including: all count first get These methods will return final results and should only be the last part of the query: movie = await Movie . query () . all () But some of the query methods return queryset again, so you can chain them together: query sort skip limit movies = await Movie . query ({ Movie . name : \"Example\" }) . skip ( 10 ) . limit ( 20 ) . all () movies = await Movie . query ({ Movie . name : \"Example\" }) . query ({ Movie . year : 2005 }) . all ()","title":"Chaining queries"},{"location":"queriying_documents/#updating-documents","text":"MongoX provides the same updateOne and updateMany functions in MongoDB, but with a different API. You can update a document by calling save on it: movie = await Movie . query () . get () movie . name = \"Another Movie\" movie = await movie . save () Here the output of save will also be a Movie instance. This is the equivalent of a MongoDB updateOne . You can also do bulk updates like this: movies = await Movie . query ({ Movie . year : 1970 }) . update ({ Movie . year : 1980 }) Here we do an update to change the year of all 1970 movies to 1980. The returned result is a list of update Movie instances. This is the equivalent of updateMany in MongoDB. Note Note how bulk update is called on Movie class, but single update is called on Movie instance.","title":"Updating documents"},{"location":"queriying_documents/#deleting-documents","text":"The same as update, MongoX provides MongoDB deleteOne and deleteMany functions but with a different API. In order to delete a single document you should get a document first, then call delete on it: movie = await Movie . query () . get () await movie . delete () This will remove the movie instance and it is the equivalent of a deleteOne . To delete multiple documents at the same time: number_of_deleted = await Movie . query ({ Movie . year : 1980 }) . delete () This will remove all documents having year equal to 1980, and the returned result is the number of documents deleted.","title":"Deleting documents"}]}